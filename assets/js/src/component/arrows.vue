<template>
  <svg class="arrows" width="100%" height="100%">
    <template v-for="path in pathes" v-if="path.line">
      <path :d="path.line"  fill="none" stroke="#DDDDDD" stroke-width="2"></path>
      <path fill-rule="evenodd" :transform="`rotate(${path.arrow.angle}, ${path.arrow.x}, ${path.arrow.y}) translate(${path.arrow.x - 8}, ${path.arrow.y - 7})`" clip-rule="evenodd" d="M8 7L0 14L0 0L8 7Z" fill="#E7E7E7"/>
    </template>
    <!-- <circle cx="10" cy="10" r="5" fill="#FAFAFA" stroke="#DDDDDD" stroke-width="2"/>
    <circle cx="726" cy="180" r="5"          fill="#FAFAFA" stroke="#DDDDDD" />
    <path   d="M 726 180 C 276 87 270 10 0 0" fill="none" stroke="#DDDDDD"/> -->
  </svg>  
</template>
<script>
const config = {
  // elementDistance: 50,
};
const absolute = function(x) {
    return (x < 0) ? -x : x;
}
const signum = function(x) {
    return (x < 0) ? -1 : 1;
}

export default {
  data() {
    return {
      pathes: []
    }
  },

  props: ['refs', 'arrows'],
  
  methods: {
    recalcPathes() {
      const { refs, getElement } = this;
      const areaRect = this.$el.getBoundingClientRect();
      
      this.pathes = this.arrows.map(arrow => {
        const startRect = getElement(arrow.parent).$el.getBoundingClientRect();
        const endRect = getElement(arrow.child).$el.getBoundingClientRect();
        const isOnTop = startRect.top + startRect.height < endRect.top;
        const isOnBottom = startRect.top > endRect.top + endRect.height;
        const isOnRight = startRect.left + startRect.width < endRect.left;
        const isOnLeft = startRect.left > endRect.left + endRect.width

        if(!isOnTop && !isOnBottom && !isOnRight && !isOnLeft) return;

        const startX = (((isOnTop || isOnBottom) && startRect.left + 0.5 * startRect.width) ||
          (isOnRight && startRect.left + startRect.width) ||
          (isOnLeft && startRect.left)) - areaRect.left;

        const startY = ((isOnTop && startRect.top + startRect.height) || 
          (isOnBottom && startRect.top) ||
          ((isOnLeft || isOnRight) && startRect.top + 0.5 * startRect.height)) - areaRect.top

        const endX = (((isOnTop || isOnBottom) && endRect.left + 0.5 * endRect.width) ||
          (isOnRight && endRect.left) ||
          (isOnLeft && endRect.left + endRect.width)) - areaRect.left;

        const endY = ((isOnTop && endRect.top) || 
          (isOnBottom && endRect.top + endRect.height) ||
          ((isOnLeft || isOnRight) && endRect.top + 0.5 * endRect.height)) - areaRect.top
        
        const deltaX = (endX - startX) * .5
        const deltaY = (endY - startY) * .5
        
        let path = ((isOnTop || isOnBottom) && `M${ startX } ${ startY } Q${ startX } ${ startY + deltaY } ${ endX - deltaX } ${ endY - deltaY } T${ endX } ${ endY }`) || 
          ((isOnLeft || isOnRight) && `M${ startX } ${ startY } Q${ startX + deltaX } ${ startY } ${ endX - deltaX } ${ endY - deltaY } T${ endX } ${ endY }`)
       
        let angle = (isOnTop && 90) || (isOnBottom && 270) || (isOnLeft && 180) || 0;
        // if (startRect.top + startRect.height < endRect.top) {
        //   endX = endRect.left + 0.5 * endRect.width - areaRect.left
        //   endY = endRect.top - areaRect.top

        //   deltaX = (endX - startX) * .5
        //   deltaY = (endY - startY) * .5

        //   angle = 90

        //   path = `M${ startX } ${ startY } Q${ startX } ${ startY + deltaY } ${ endX - deltaX } ${ endY - deltaY } T${ endX } ${ endY }`
        // } else if (startRect.top > endRect.top + endRect.height) {
        //   startX = startRect.left + 0.5 * startRect.width - areaRect.left
        //   startY = startRect.top - areaRect.top

        //   endX = endRect.left + 0.5 * endRect.width - areaRect.left
        //   endY = endRect.top + endRect.height - areaRect.top

        //   deltaX = (endX - startX) * .5
        //   deltaY = (endY - startY) * .5

        //   angle = 270

        //   path = `M${ startX } ${ startY } Q${ startX } ${ startY + deltaY } ${ endX - deltaX } ${ endY - deltaY } T${ endX } ${ endY }`
        // } else {
        //   if (startRect.left + startRect.width < endRect.left) {
        //     startX = startRect.left + startRect.width - areaRect.left
        //     startY = startRect.top + 0.5 * startRect.height - areaRect.top

        //     endX = endRect.left - areaRect.left
        //     endY = endRect.top + 0.5 * endRect.height - areaRect.top

        //     deltaX = (endX - startX) * .5
        //     deltaY = (endY - startY) * .5

        //     path = `M${ startX } ${ startY } Q${ startX + deltaX } ${ startY } ${ endX - deltaX } ${ endY - deltaY } T${ endX } ${ endY }`
        //   } else if (startRect.left > endRect.left + endRect.width) {
        //     startX = startRect.left - areaRect.left
        //     startY = startRect.top + 0.5 * startRect.height - areaRect.top

        //     endX = endRect.left + endRect.width - areaRect.left
        //     endY = endRect.top + 0.5 * endRect.height - areaRect.top

        //     deltaX = (endX - startX) * .5
        //     deltaY = (endY - startY) * .5

        //     angle = 180

        //     path = `M${ startX } ${ startY } Q${ startX + deltaX } ${ startY } ${ endX - deltaX } ${ endY - deltaY } T${ endX } ${ endY }`
        //   }
        // }
        
        return {
          line: path, 
          arrow: {
            x: endX,
            y: endY,
            angle
          }
        }
      })
    },

    getElement(id) {
      const { refs } = this;
      
      if (refs.hasOwnProperty(id)) return refs[id];

      const step = refs.steps.find(step => step.$refs.hasOwnProperty(id))

      return step && step.$refs[id];
    }
  },

  mounted() {
    this.recalcPathes()
  }
}
</script>
<style lang="scss">
  .arrows {
    position: absolute;
    left: 0;
    right: 0;
    z-index: 1;
    pointer-events: none;
  }
</style>
